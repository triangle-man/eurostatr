##' Load a dataset from Eurostat.
##'
##' Read a Eurostat data file and reformat as a data frame in "tidy" format.
##'
##' A Eurostat data table is a tab-separated-values file, having the structure
##' of a cross-tab. There is a single dimension for the column headings and
##' possibly multiple dimensions for the row headings, as follows:--
##' \tabular{lrrrrr}{
##'  AA,BB,CC\\XX \tab x1 \tab x2 \tab x3 \tab x4 \tab ... \cr
##'   a1,b1,c1    \tab  v \tab  v \tab  v \tab  v \tab ... \cr
##'   a1,b1,c2    \tab  v \tab  v \tab  v \tab  v \tab ... \cr
##'   ...         \tab .. \tab .. \tab .. \tab .. \tab ..
##' }
##' 
##' The \code{AA}, \code{BB}, \code{CC}, \code{XX} are the names of the
##' variables that specify an observation; the \code{an}, \code{bn}, \code{cn},
##' \code{xn}, ... are the corresponding values of each observation
##' variable. The \code{v} are the values of the measured variable, whose name
##' is not given by Eurostat (this name can be supplied by the parameter
##' \code{value.name}).
##'
##' The values, \code{v}, may be either a single field or a field followed by a space
##' followed by zero or more characters (indicating flags).
##'
##' The header of the first column, \code{AA,BB,CC\\XX} contains the names of
##' \emph{all} the variables. If there are \eqn{N} variables, then this string
##' has \eqn{N-1} names separated by commas, a backslash, and one more name.
##'
##' It is not clear to me what happens in the case \eqn{N < 2}.
##'
##' Missing values are denoted in Eurostat data tables by the character \code{:}
##'
##' @param file Path to the file to import.
##' @param value.name The name to be given, in the resulting data frame, to the
##' variable given by this dataset.
##' @return A data frame in "tidy" format.
##' @export
read.eurostat <- function(file, value.name = "value") {
    read.delim(file = file,
               na.strings = c(":", ": "), 
               check.names = FALSE,
               stringsAsFactors = FALSE # Need to strsplit first column later
               ) %>%
                   gather_("_slashvar", value.name, -1, convert = TRUE) %>% # FIXME: Use an autogenerated name instead of "_slashvar"
                       split_and_rename_variables() %>%
                           split_flags(value.name)
 }

##' Split observation variables into separate columns
##'
##' Breaks out first column of Eurostat data table into multiple variables.
##'
##' 
##' @param df A dataframe, having three columns
##' \enumerate{
##' \item The observation variables (as one column);
##' \item The measure variable;
##' \item Any flags.
##' }
##' @return A data frame.
split_and_rename_variables <- function(df) {
    if (ncol(df) !=3 )
        stop("something went wrong in the conversion process.")

    obs_var_header <- names(df)[[1]]
    obs_vars <- parse_variable_names(obs_var_header)

    structure(
        separate_(df, obs_var_header, into = obs_vars[[1]], sep = ","),
        names = c(obs_vars[[1]], obs_vars[[2]], names(df)[[ncol(df)]]))
}

##' Parse names of observation variables
##'
##' Split out the names from Eurostat's first column header 
##' 
##'
##' @param x A string from the header of the first column. 
##' @return A list of length two: a vector of the first set of
##' observation variables, and the last observation variable.
parse_variable_names <- function(x) {
    ns <- strsplit(x, ",|\\\\")[[1]]
    if (length(ns) < 2)
        stop("dataset has fewer than two variables: I can't cope")

    list(ns[1:(length(ns)-1)], ns[length(ns)])
}


##' Split flags from the measure variable
##'
##' Parse the measure variable to extract any flags.
##'
##' 
##' @param df A data frame 
##' @param value.name The column containing the measure variable.
##' @return A new data frame, with an additional column.
split_flags <- function(df, value.name) {
    if (is.numeric(df[[value.name]])) return(df)  # There are no flags
    
    value_and_flags <- do.call(rbind,
                               lapply(strsplit(df[[value.name]],
                                               split = " ", fixed = TRUE),
                                      `[`, 1:2)) 

    ## FIXME: Perhaps the final value.name variable should be converted to
    ## numeric if it looks like a numeric vector?
    cbind(df[!(names(df) == value.name)],
          structure(data.frame(value_and_flags),
                    names = c(value.name, "flags")))
}
       


